name: Patch Kernel with WildKSU

on:
  push:
    branches: [ master ]
  workflow_dispatch:
    inputs:
      firmware_dir:
        description: 'Firmware directory'
        default: ''
      kernel_version:
        description: 'Kernel version'
        default: ''

jobs:
  patch:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          lfs: true
          fetch-depth: 0

      - name: Tools
        run: |
          wget https://github.com/magojohnji/magiskboot-linux/raw/main/x86_64/magiskboot -O magiskboot
          chmod +x magiskboot

      - name: Build
        id: build
        env:
          GH_TOKEN: ${{ github.token }}
          FW_IN: ${{ github.event.inputs.firmware_dir }}
          KV_IN: ${{ github.event.inputs.kernel_version }}
        run: |
          # Detect Firmware
          FW_DIR="$FW_IN"
          if [ -z "$FW_DIR" ]; then FW_DIR=$(ls -d firmware_* | sort -V | tail -n 1); fi
          echo "Using firmware: $FW_DIR"
          
          # Unpack
          ./magiskboot unpack "$FW_DIR/boot.img"
          mv kernel kernel.stock
          
          # Detect Version
          K_VER="$KV_IN"
          if [ -z "$K_VER" ]; then K_VER=$(strings kernel.stock | grep "Linux version " | awk '{print $3}' | cut -d'-' -f1); fi
          echo "Using kver: $K_VER"
          echo "kver=$K_VER" >> $GITHUB_OUTPUT
          
          # Download WildKSU
          R_TAG=$(gh release list --repo WildKernels/GKI_KernelSU_SUSFS --limit 1 | awk '{print $3}')
          ASSET=$(gh release view "$R_TAG" --repo WildKernels/GKI_KernelSU_SUSFS --json assets --jq ".assets[] | select(.name | contains(\"$K_VER\") and contains(\"Normal\")) | .name" | head -n 1)
          if [ -z "$ASSET" ]; then echo "No GKI for $K_VER"; exit 1; fi
          gh release download "$R_TAG" --repo WildKernels/GKI_KernelSU_SUSFS --pattern "$ASSET"
          unzip "$ASSET" Image
          
          # Patch Strings
          export S_FULL=$(strings kernel.stock | grep "Linux version " | head -n 1)
          export W_FULL=$(strings Image | grep "Linux version " | head -n 1)
          python3 -c "
import os, sys
s, w = os.environ['S_FULL'].encode(), os.environ['W_FULL'].encode()
with open('Image', 'rb') as f: data = f.read()
if w in data:
    if len(s) <= len(w):
        print('Patching...')
        padded = s + b'\x00' * (len(w) - len(s))
        with open('kernel', 'wb') as f: f.write(data.replace(w, padded))
    else:
        print('Warning: Stock string too long'); with open('kernel', 'wb') as f: f.write(data)
else:
    with open('kernel', 'wb') as f: f.write(data)
"
          # Repack
          ./magiskboot repack "$FW_DIR/boot.img" patched_boot.img

      - name: Update README
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          W_APP=$(gh release view --repo WildKernels/Wild_KSU --json tagName --jq .tagName)
          Z_NX=$(gh release view --repo Dr-TSNG/ZygiskNext --json tagName --jq .tagName)
          M_OV=$(gh release view --repo KernelSU-Modules-Repo/meta-overlayfs --json tagName --jq .tagName)
          S_MD=$(gh release view --repo sidex15/susfs4ksu-module --json tagName --jq .tagName)
          sed -i "s|Wild_KSU/releases/tag/[^)]*|Wild_KSU/releases/tag/$W_APP|g" README.md
          sed -i "s|ZygiskNext/releases/tag/[^)]*|ZygiskNext/releases/tag/$Z_NX|g" README.md
          sed -i "s|meta-overlayfs/releases/tag/[^)]*|meta-overlayfs/releases/tag/$M_OV|g" README.md
          sed -i "s|susfs4ksu-module/releases/tag/[^)]*|susfs4ksu-module/releases/tag/$S_MD|g" README.md
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          if ! git diff --exit-code README.md; then
            git add README.md
            git commit -m "Docs: Auto-update" && git push origin master
          fi

      - name: Release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          K_VER="${{ steps.build.outputs.kver }}"
          TAG="build-$K_VER-${{ github.run_number }}"
          gh release create "$TAG" patched_boot.img --title "Update $TAG" --notes "Patched"